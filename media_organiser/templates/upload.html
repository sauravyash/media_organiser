<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Media Organiser ‚Äî Upload</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Outfit:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0f1216;
      --surface: #1a1e26;
      --border: #2a303c;
      --text: #e6edf3;
      --muted: #7d8590;
      --accent: #3fb950;
      --accent-dim: #238636;
      --danger: #f85149;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg);
      color: var(--text);
      font-family: "Outfit", system-ui, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
    }
    h1 {
      font-family: "JetBrains Mono", monospace;
      font-weight: 600;
      font-size: 1.25rem;
      letter-spacing: 0.02em;
      color: var(--muted);
      margin-bottom: 0.25rem;
    }
    .sub {
      font-size: 0.875rem;
      color: var(--muted);
      margin-bottom: 2rem;
    }
    #form {
      width: 100%;
      max-width: 32rem;
      overflow: auto;
    }
    .zone {
      width: 100%;
      max-width: 32rem;
      min-height: 14rem;
      border: 2px dashed var(--border);
      border-radius: 12px;
      background: var(--surface);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.75rem;
      padding: 2rem;
      transition: border-color 0.2s, background 0.2s;
      cursor: pointer;
    }
    .zone:hover, .zone.dragover {
      border-color: var(--accent);
      background: rgba(63, 185, 80, 0.06);
    }
    .zone input[type="file"] {
      display: none;
    }
    .zone .icon {
      font-size: 2.5rem;
      opacity: 0.7;
    }
    .zone .prompt {
      font-size: 0.9375rem;
      color: var(--muted);
      text-align: center;
    }
    .zone .prompt strong { color: var(--text); }
    .linkBtn {
      background: none;
      border: none;
      color: var(--accent);
      font: inherit;
      cursor: pointer;
      padding: 0;
      text-decoration: underline;
    }
    .linkBtn:hover { color: var(--accent-dim); }
    .exts {
      font-family: "JetBrains Mono", monospace;
      font-size: 0.75rem;
      color: var(--muted);
      margin-top: 0.5rem;
      display: block;
      text-align: center;
    }
    .exts span { color: var(--accent); }
    .btn {
      margin-top: 1.5rem;
      float: right;
      font-family: "JetBrains Mono", monospace;
      font-size: 0.8125rem;
      font-weight: 600;
      padding: 0.625rem 1.25rem;
      border: none;
      border-radius: 8px;
      background: var(--accent);
      color: var(--bg);
      cursor: pointer;
      transition: background 0.2s;
    }
    .btn:hover { background: var(--accent-dim); }
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .feedback {
      margin-top: 1.5rem;
      max-width: 32rem;
      width: 100%;
      font-size: 0.875rem;
    }
    .feedback.success { color: var(--accent); }
    .feedback.error { color: var(--danger); }
    .feedback ul { margin: 0.25rem 0 0 1rem; padding: 0; }
    .folder-browser {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(15, 18, 22, 0.95);
      z-index: 1000;
      padding: 2rem;
      overflow: auto;
    }
    .folder-browser.active {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .browser-window {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      width: 100%;
      max-width: 60rem;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }
    .browser-header {
      padding: 1.25rem 1.5rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .browser-header h2 {
      margin: 0;
      font-size: 1.125rem;
      font-weight: 600;
      color: var(--text);
    }
    .browser-close {
      background: none;
      border: none;
      color: var(--muted);
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0;
      width: 2rem;
      height: 2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: background 0.2s, color 0.2s;
    }
    .browser-close:hover {
      background: var(--border);
      color: var(--text);
    }
    .browser-content {
      flex: 1;
      overflow: auto;
      padding: 1rem;
    }
    .browser-breadcrumb {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border);
      font-family: "JetBrains Mono", monospace;
      font-size: 0.8125rem;
      color: var(--muted);
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }
    .breadcrumb-item {
      cursor: pointer;
      color: var(--accent);
      transition: color 0.2s;
    }
    .breadcrumb-item:hover {
      color: var(--accent-dim);
    }
    .breadcrumb-separator {
      color: var(--muted);
    }
    .file-tree {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .file-tree-item {
      padding: 0.5rem 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      border-radius: 6px;
      transition: background 0.2s;
      cursor: pointer;
    }
    .file-tree-item:hover {
      background: rgba(63, 185, 80, 0.08);
    }
    .file-tree-item input[type="checkbox"] {
      width: 1.125rem;
      height: 1.125rem;
      cursor: pointer;
      accent-color: var(--accent);
    }
    .file-tree-item-label {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.9375rem;
      color: var(--text);
    }
    .file-icon {
      font-size: 1.125rem;
      width: 1.25rem;
      text-align: center;
    }
    .file-name {
      flex: 1;
    }
    .file-size {
      font-family: "JetBrains Mono", monospace;
      font-size: 0.75rem;
      color: var(--muted);
      margin-left: auto;
    }
    .folder-item {
      font-weight: 500;
    }
    .browser-footer {
      padding: 1rem 1.5rem;
      border-top: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
    }
    .selected-count {
      font-size: 0.875rem;
      color: var(--muted);
    }
    .browser-actions {
      display: flex;
      gap: 0.75rem;
    }
    .browser-btn {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 6px;
      font-family: "JetBrains Mono", monospace;
      font-size: 0.8125rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }
    .browser-btn-primary {
      background: var(--accent);
      color: var(--bg);
    }
    .browser-btn-primary:hover {
      background: var(--accent-dim);
    }
    .browser-btn-secondary {
      background: var(--border);
      color: var(--text);
    }
    .browser-btn-secondary:hover {
      background: #353b47;
    }
    .upload-progress {
      display: none;
      padding: 1rem 1.5rem;
      border-top: 1px solid var(--border);
      background: var(--surface);
    }
    .upload-progress.active {
      display: block;
    }
    .progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
      font-size: 0.875rem;
      color: var(--text);
    }
    .progress-status {
      font-family: "JetBrains Mono", monospace;
      color: var(--muted);
    }
    .progress-bar-container {
      width: 100%;
      height: 8px;
      background: var(--border);
      border-radius: 4px;
      overflow: hidden;
      position: relative;
    }
    .progress-bar-fill {
      height: 100%;
      background: var(--accent);
      border-radius: 4px;
      transition: width 0.3s ease;
      width: 0%;
    }
    .progress-bar-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      right: 0;
      background: linear-gradient(
        90deg,
        transparent,
        rgba(255, 255, 255, 0.2),
        transparent
      );
      animation: shimmer 1.5s infinite;
    }
    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }
    .progress-details {
      margin-top: 0.5rem;
      font-size: 0.75rem;
      color: var(--muted);
      font-family: "JetBrains Mono", monospace;
    }
  </style>
</head>
<body>
  <h1>media_organiser</h1>
  <p class="sub">Upload media to import. Files are organised into /movies and /tv automatically.</p>

  <form id="form" action="{{ url_for('upload') }}" method="post" enctype="multipart/form-data">
    <div class="zone" id="zone" role="button" tabindex="0">
      <input type="file" name="files" id="files" multiple>
      <input type="file" name="folder" id="folder" webkitdirectory style="display:none">
      <span class="icon" aria-hidden="true">üìÅ</span>
      <span class="prompt"><strong>Drop files here</strong> or <button type="button" class="linkBtn" id="pickFolder">choose folder</button> / <button type="button" class="linkBtn" id="pickFiles">choose files</button></span>
      <span class="exts">All file types ‚Ä¢ Folder upload preserves structure (NFO, subtitles, images)</span>
    </div>
  </form>

  <div class="feedback" id="feedback" aria-live="polite"></div>

  <div class="folder-browser" id="folderBrowser">
    <div class="browser-window">
      <div class="browser-header">
        <h2>Select Files to Upload</h2>
        <button class="browser-close" id="browserClose" aria-label="Close">√ó</button>
      </div>
      <div class="browser-breadcrumb" id="breadcrumb"></div>
      <div class="browser-content" id="browserContent"></div>
      <div class="browser-footer">
        <div class="selected-count" id="selectedCount">0 files selected</div>
        <div class="browser-actions">
          <button class="browser-btn browser-btn-secondary" id="cancelBtn">Cancel</button>
          <button class="browser-btn browser-btn-primary" id="confirmBtn">Upload Selected</button>
        </div>
      </div>
      <div class="upload-progress" id="uploadProgress">
        <div class="progress-header">
          <span>Uploading files...</span>
          <span class="progress-status" id="progressStatus">0%</span>
        </div>
        <div class="progress-bar-container">
          <div class="progress-bar-fill" id="progressBarFill"></div>
        </div>
        <div class="progress-details" id="progressDetails">Preparing upload...</div>
      </div>
    </div>
  </div>

  <script>
    const zone = document.getElementById("zone");
    const filesInput = document.getElementById("files");
    const folderInput = document.getElementById("folder");
    const submitBtn = document.getElementById("submitBtn"); // May be null if button removed
    const feedback = document.getElementById("feedback");
    const form = document.getElementById("form");
    const folderBrowser = document.getElementById("folderBrowser");
    const browserContent = document.getElementById("browserContent");
    const breadcrumb = document.getElementById("breadcrumb");
    const selectedCount = document.getElementById("selectedCount");
    const browserClose = document.getElementById("browserClose");
    const cancelBtn = document.getElementById("cancelBtn");
    const confirmBtn = document.getElementById("confirmBtn");
    const uploadProgress = document.getElementById("uploadProgress");
    const progressBarFill = document.getElementById("progressBarFill");
    const progressStatus = document.getElementById("progressStatus");
    const progressDetails = document.getElementById("progressDetails");

    let folderTree = null;
    let currentPath = [];
    let selectedFiles = new Set();
    let folderFileList = null; // Store the original FileList
    let currentUploadXHR = null; // Track current upload for cancellation

    // Check if a file or folder name is hidden (starts with .)
    function isHidden(name) {
      const parts = name.split('/');
      return parts.some(part => part.startsWith('.'));
    }

    // Check if a path is a macOS extended attribute file (contains ::EA:: or ::EA)
    function isExtendedAttribute(path) {
      return path.includes('::EA::') || path.includes('::EA');
    }

    // Build tree structure from FileList
    function buildFileTree(fileList) {
      const tree = {};
      for (let i = 0; i < fileList.length; i++) {
        const file = fileList[i];
        // webkitRelativePath should be set when using webkitdirectory
        // It's relative to the selected folder root
        const path = file.webkitRelativePath || file.name;
        if (!path) continue;
        
        const parts = path.split('/').filter(p => p.length > 0);
        if (parts.length === 0) continue;
        
        let current = tree;
        for (let j = 0; j < parts.length; j++) {
          const part = parts[j];
          if (j === parts.length - 1) {
            // It's a file
            current[part] = { type: 'file', file: file, path: path };
          } else {
            // It's a folder
            if (!current[part]) {
              current[part] = { type: 'folder', children: {} };
            }
            current = current[part].children;
          }
        }
      }
      return tree;
    }

    // Format file size
    function formatSize(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
    }

    // Get current folder from path
    function getCurrentFolder() {
      if (!folderTree) return null;
      let current = folderTree;
      for (const part of currentPath) {
        if (current && current[part] && current[part].type === 'folder') {
          current = current[part].children;
        } else {
          return null;
        }
      }
      return current;
    }

    // Render breadcrumb
    function renderBreadcrumb() {
      breadcrumb.innerHTML = '';
      const items = ['Root', ...currentPath];
      items.forEach((item, index) => {
        if (index > 0) {
          const sep = document.createElement('span');
          sep.className = 'breadcrumb-separator';
          sep.textContent = '/';
          breadcrumb.appendChild(sep);
        }
        const span = document.createElement('span');
        span.className = 'breadcrumb-item';
        span.textContent = item;
        if (index < items.length - 1) {
          span.onclick = () => {
            currentPath = currentPath.slice(0, index);
            renderFolder();
          };
        }
        breadcrumb.appendChild(span);
      });
    }

    // Render folder contents
    function renderFolder() {
      const current = getCurrentFolder();
      if (!current) return;

      renderBreadcrumb();

      // Cleanup: Remove all hidden files from selectedFiles before rendering
      // This ensures hidden files are never selected by default
      function removeHiddenFilesFromSelection(node) {
        if (!node) return;
        Object.keys(node).forEach(childName => {
          const child = node[childName];
          if (child.type === 'file' && isHidden(childName)) {
            selectedFiles.delete(child.path);
          } else if (child.type === 'folder' && child.children) {
            removeHiddenFilesFromSelection(child.children);
          }
        });
      }
      // Remove hidden files from the entire tree
      if (folderTree) {
        removeHiddenFilesFromSelection(folderTree);
      }

      const items = Object.keys(current).sort((a, b) => {
        const aIsFolder = current[a].type === 'folder';
        const bIsFolder = current[b].type === 'folder';
        if (aIsFolder && !bIsFolder) return -1;
        if (!aIsFolder && bIsFolder) return 1;
        return a.localeCompare(b);
      });

      const ul = document.createElement('ul');
      ul.className = 'file-tree';

      items.forEach(name => {
        const item = current[name];
        const li = document.createElement('li');
        li.className = 'file-tree-item';
        if (item.type === 'folder') {
          li.classList.add('folder-item');
        }

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        const itemId = item.path || (currentPath.length > 0 ? currentPath.join('/') + '/' + name : name);
        checkbox.id = `file-${itemId}`;
        
        // Check if this item is hidden
        const hidden = isHidden(name);
        
        if (item.type === 'file') {
          // Always ensure hidden files are NOT selected
          if (hidden) {
            selectedFiles.delete(item.path);
            checkbox.checked = false;
          } else {
            // For non-hidden files, check if they should be selected
            // They should be selected if they're already in selectedFiles (from showFolderBrowser or selectAllFilesInFolder)
            checkbox.checked = selectedFiles.has(item.path);
            // Ensure they're in selectedFiles if checked
            if (checkbox.checked) {
              selectedFiles.add(item.path);
            }
          }
          checkbox.onchange = (e) => {
            if (e.target.checked) {
              selectedFiles.add(item.path);
            } else {
              selectedFiles.delete(item.path);
            }
            updateSelectedCount();
          };
        } else {
          // For folders, recursively select/deselect all non-hidden children
          // IMPORTANT: This runs BEFORE individual file checkboxes are created,
          // so we need to ensure hidden files are excluded here
          function selectAllFilesInFolder(folderNode) {
            if (!folderNode || !folderNode.children) return;
            Object.keys(folderNode.children).forEach(childName => {
              const child = folderNode.children[childName];
              if (child.type === 'file') {
                // Always remove hidden files first, then only add non-hidden files
                if (isHidden(childName)) {
                  selectedFiles.delete(child.path);
                } else {
                  selectedFiles.add(child.path);
                }
              } else if (child.type === 'folder') {
                // Skip hidden folders - don't select files inside them
                if (!isHidden(childName)) {
                  selectAllFilesInFolder(child);
                }
              }
            });
          }
          // Only call this if we want to select files in this folder
          // Since we're initializing, we want to select non-hidden files
          selectAllFilesInFolder(item);
          
          // Check if folder should be checked (has any selected non-hidden children)
          // IMPORTANT: Hidden folders should always be unchecked
          function hasSelectedChildren(folderNode) {
            if (!folderNode || !folderNode.children) return false;
            for (const childName of Object.keys(folderNode.children)) {
              const child = folderNode.children[childName];
              if (child.type === 'file' && !isHidden(childName) && selectedFiles.has(child.path)) {
                return true;
              } else if (child.type === 'folder' && !isHidden(childName) && hasSelectedChildren(child)) {
                return true;
              }
            }
            return false;
          }
          // Hidden folders should always be unchecked
          checkbox.checked = hidden ? false : hasSelectedChildren(item);
          
          checkbox.onchange = (e) => {
            // Don't allow hidden folders to be checked
            if (hidden) {
              checkbox.checked = false;
              return;
            }
            toggleFolderSelection(item, e.target.checked);
            updateSelectedCount();
          };
        }

        const label = document.createElement('div');
        label.className = 'file-tree-item-label';
        
        const icon = document.createElement('span');
        icon.className = 'file-icon';
        icon.textContent = item.type === 'folder' ? 'üìÅ' : 'üìÑ';
        
        const fileName = document.createElement('span');
        fileName.className = 'file-name';
        fileName.textContent = name;
        
        label.appendChild(icon);
        label.appendChild(fileName);

        if (item.type === 'file') {
          const size = document.createElement('span');
          size.className = 'file-size';
          size.textContent = formatSize(item.file.size);
          label.appendChild(size);
        }

        li.appendChild(checkbox);
        li.appendChild(label);

        if (item.type === 'folder') {
          li.onclick = (e) => {
            if (e.target.type !== 'checkbox') {
              currentPath.push(name);
              renderFolder();
            }
          };
        }

        ul.appendChild(li);
      });

      browserContent.innerHTML = '';
      browserContent.appendChild(ul);
      updateSelectedCount();
    }

    // Toggle folder selection (select/deselect all children)
    function toggleFolderSelection(folderItem, checked) {
      function traverse(node) {
        if (!node || !node.children) return;
        Object.keys(node.children).forEach(name => {
          const child = node.children[name];
          if (child.type === 'file') {
            if (checked) {
              // When checking, only add non-hidden files
              if (!isHidden(name)) {
                selectedFiles.add(child.path);
              }
            } else {
              // When unchecking, remove all files
              selectedFiles.delete(child.path);
            }
            // Update checkbox if it exists
            const checkbox = document.getElementById(`file-${child.path}`);
            if (checkbox) {
              checkbox.checked = checked && !isHidden(name);
            }
          } else if (child.type === 'folder') {
            // Skip hidden folders - don't traverse into them or select their contents
            if (!isHidden(name)) {
              traverse(child);
              // Update folder checkbox if it exists
              const folderCheckbox = document.getElementById(`file-${child.path || name}`);
              if (folderCheckbox) {
                folderCheckbox.checked = checked;
              }
            }
          }
        });
      }
      traverse(folderItem);
    }

    // Update selected count
    function updateSelectedCount() {
      const count = selectedFiles.size;
      selectedCount.textContent = `${count} file${count !== 1 ? 's' : ''} selected`;
      confirmBtn.disabled = count === 0;
    }

    // Show folder browser
    function showFolderBrowser(fileList) {
      // #region agent log
      fetch('http://127.0.0.1:7244/ingest/748ea684-e073-4f05-a7f9-757a7041c34a',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'upload.html:722',message:'showFolderBrowser called',data:{fileListLength:fileList?fileList.length:0,folderBrowserActiveBefore:folderBrowser.classList.contains('active')},timestamp:Date.now(),runId:'debug1',hypothesisId:'C'})}).catch(()=>{});
      // #endregion
      if (!fileList || fileList.length === 0) {
        return;
      }
      
      folderFileList = fileList; // Store the FileList
      folderTree = buildFileTree(fileList);
      currentPath = [];
      selectedFiles.clear();
      
      // Select all non-hidden files by default
      for (let i = 0; i < fileList.length; i++) {
        const file = fileList[i];
        const path = file.webkitRelativePath || file.name;
        // Only add non-hidden files (files whose name or any path component starts with .)
        if (!isHidden(path)) {
          selectedFiles.add(path);
        }
      }
      
      renderFolder();
      folderBrowser.classList.add('active');
      // #region agent log
      fetch('http://127.0.0.1:7244/ingest/748ea684-e073-4f05-a7f9-757a7041c34a',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'upload.html:743',message:'showFolderBrowser after adding active class',data:{folderBrowserActive:folderBrowser.classList.contains('active')},timestamp:Date.now(),runId:'debug1',hypothesisId:'C'})}).catch(()=>{});
      // #endregion
      // Enable button if there are selected files
      confirmBtn.disabled = selectedFiles.size === 0;
    }

    // Hide folder browser
    function hideFolderBrowser() {
      // #region agent log
      fetch('http://127.0.0.1:7244/ingest/748ea684-e073-4f05-a7f9-757a7041c34a',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'upload.html:749',message:'hideFolderBrowser called',data:{folderBrowserActiveBefore:folderBrowser.classList.contains('active'),folderInputValueBefore:folderInput.value,folderInputFilesLengthBefore:folderInput.files.length},timestamp:Date.now(),runId:'debug1',hypothesisId:'D'})}).catch(()=>{});
      // #endregion
      if (currentUploadXHR) {
        currentUploadXHR.abort();
        currentUploadXHR = null;
      }
      folderBrowser.classList.remove('active');
      uploadProgress.classList.remove('active');
      folderTree = null;
      currentPath = [];
      selectedFiles.clear();
      folderFileList = null;
      folderInput.value = '';
      // #region agent log
      fetch('http://127.0.0.1:7244/ingest/748ea684-e073-4f05-a7f9-757a7041c34a',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'upload.html:760',message:'hideFolderBrowser after clearing',data:{folderBrowserActive:folderBrowser.classList.contains('active'),folderInputValue:folderInput.value,folderInputFilesLength:folderInput.files.length},timestamp:Date.now(),runId:'debug1',hypothesisId:'D'})}).catch(()=>{});
      // #endregion
      confirmBtn.disabled = false;
      cancelBtn.disabled = false;
    }

    // Event listeners
    document.getElementById("pickFiles").addEventListener("click", (e) => { 
      e.stopPropagation(); 
      folderInput.value = ""; 
      filesInput.click(); 
    });
    
    document.getElementById("pickFolder").addEventListener("click", (e) => { 
      // #region agent log
      fetch('http://127.0.0.1:7244/ingest/748ea684-e073-4f05-a7f9-757a7041c34a',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'upload.html:772',message:'pickFolder clicked',data:{folderBrowserActive:folderBrowser.classList.contains('active'),folderInputValue:folderInput.value,folderInputFilesLength:folderInput.files.length},timestamp:Date.now(),runId:'debug1',hypothesisId:'A'})}).catch(()=>{});
      // #endregion
      e.stopPropagation(); 
      filesInput.value = ""; 
      folderInput.click(); 
    });

    folderInput.addEventListener("change", (e) => {
      // #region agent log
      fetch('http://127.0.0.1:7244/ingest/748ea684-e073-4f05-a7f9-757a7041c34a',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'upload.html:778',message:'folderInput change event',data:{filesLength:e.target.files.length,folderBrowserActive:folderBrowser.classList.contains('active'),folderInputValue:folderInput.value},timestamp:Date.now(),runId:'debug1',hypothesisId:'B'})}).catch(()=>{});
      // #endregion
      if (e.target.files.length > 0) {
        showFolderBrowser(e.target.files);
      }
    });

    browserClose.addEventListener("click", () => {
      if (currentUploadXHR) {
        currentUploadXHR.abort();
        currentUploadXHR = null;
      }
      hideFolderBrowser();
    });
    cancelBtn.addEventListener("click", () => {
      if (currentUploadXHR) {
        currentUploadXHR.abort();
        currentUploadXHR = null;
      }
      hideFolderBrowser();
    });
    
    confirmBtn.addEventListener("click", async () => {
      if (selectedFiles.size === 0) return;
      
      // Show progress bar
      uploadProgress.classList.add("active");
      progressBarFill.style.width = "0%";
      progressStatus.textContent = "0%";
      progressDetails.textContent = "Preparing upload...";
      
      // Disable buttons during upload
      confirmBtn.disabled = true;
      cancelBtn.disabled = true;
      if (submitBtn) submitBtn.disabled = true;
      feedback.textContent = "";
      feedback.className = "feedback";

      // Create a map of paths to files using stored FileList
      const fileMap = new Map();
      const fileListToUse = folderFileList || folderInput.files;
      const selectedFileArray = [];
      for (let i = 0; i < fileListToUse.length; i++) {
        const file = fileListToUse[i];
        const path = file.webkitRelativePath || file.name;
        fileMap.set(path, file);
        // Only include files that are selected AND not extended attribute files
        if (selectedFiles.has(path) && !isExtendedAttribute(path)) {
          selectedFileArray.push({ file, path });
        }
      }

      // Calculate total size for progress tracking
      let totalSize = 0;
      selectedFileArray.forEach(({ file }) => {
        totalSize += file.size;
      });

      // Update progress details
      progressDetails.textContent = `Uploading ${selectedFileArray.length} file${selectedFileArray.length !== 1 ? 's' : ''} (${formatSize(totalSize)})...`;

      // Track upload progress
      let uploadedBytes = 0;
      const allSaved = [];
      const allRejected = [];
      const allUnselected = [];
      let uploadCancelled = false;
      
      // Track unselected files (files in folder but not selected)
      // Also track which files were actually sent to backend for proper rejection tracking
      const filesActuallySent = new Set();
      const allFilesInFolder = new Set();
      for (let i = 0; i < fileListToUse.length; i++) {
        const file = fileListToUse[i];
        const path = file.webkitRelativePath || file.name;
        allFilesInFolder.add(path);
      }
      // Unselected files are those in folder but not in selectedFiles (excluding extended attributes)
      allFilesInFolder.forEach(path => {
        if (!selectedFiles.has(path) && !isExtendedAttribute(path)) {
          allUnselected.push(path);
        }
      });
      // Track which files we're actually sending
      selectedFileArray.forEach(({ path }) => {
        filesActuallySent.add(path);
      });

      // Upload files sequentially, one at a time
      for (let i = 0; i < selectedFileArray.length; i++) {
        if (uploadCancelled) break;
        
        const { file, path } = selectedFileArray[i];
        const currentFileIndex = i + 1;
        
        try {
          await new Promise((resolve, reject) => {
            const fd = new FormData();
            fd.append("files", file);
            fd.append("paths", path);

            const xhr = new XMLHttpRequest();
            currentUploadXHR = xhr; // Store for cancellation
            
            xhr.upload.addEventListener("progress", (e) => {
              if (e.lengthComputable && !uploadCancelled) {
                // Calculate overall progress: bytes uploaded so far + current file progress
                const currentFileProgress = e.loaded;
                const totalUploaded = uploadedBytes + currentFileProgress;
                const percentComplete = Math.round((totalUploaded / totalSize) * 100);
                
                progressBarFill.style.width = percentComplete + "%";
                progressStatus.textContent = percentComplete + "%";
                
                const uploadedSize = formatSize(totalUploaded);
                const totalSizeStr = formatSize(totalSize);
                const fileName = path.split('/').pop(); // Get just the filename
                progressDetails.textContent = `[${currentFileIndex}/${selectedFileArray.length}] Uploading ${fileName}... ${uploadedSize} / ${totalSizeStr}`;
              }
            });

            xhr.addEventListener("load", () => {
              currentUploadXHR = null;
              // Update uploadedBytes immediately when file completes
              uploadedBytes += file.size;
              
              // Update progress bar to show completed file
              const percentComplete = Math.round((uploadedBytes / totalSize) * 100);
              progressBarFill.style.width = percentComplete + "%";
              progressStatus.textContent = percentComplete + "%";
              
              if (xhr.status >= 200 && xhr.status < 300) {
                try {
                  const data = JSON.parse(xhr.responseText);
                  
                  // Track which files were saved to avoid adding them to rejected
                  const savedPaths = new Set();
                  const savedBasePaths = new Set(); // Track base paths for better matching
                  
                  // Since we upload one file at a time, process the response for this specific file
                  // IMPORTANT: Process saved files first, then rejected files
                  if (data.saved && data.saved.length > 0) {
                    // Add all saved files (filter out extended attributes)
                    data.saved.forEach(savedPath => {
                      if (!isExtendedAttribute(savedPath)) {
                        allSaved.push(savedPath);
                        // Normalize path for comparison (remove any error suffixes and duplicate markers)
                        const normalized = savedPath.split(' (error:')[0].split(' (Network error)')[0].split(' (Upload error)')[0];
                        savedPaths.add(normalized);
                        // Also track the base filename for matching (in case backend renamed due to duplicates)
                        const baseName = normalized.split('/').pop();
                        savedBasePaths.add(baseName);
                      }
                    });
                    // Also track the original path we sent (only if we actually saved something)
                    // This handles cases where backend might return a slightly different path
                    savedPaths.add(path);
                    const originalBaseName = path.split('/').pop();
                    savedBasePaths.add(originalBaseName);
                  }
                  
                  // Only process rejected files if they weren't already saved
                  // This prevents files from appearing in both saved and rejected
                  // IMPORTANT: Since we upload one file at a time, if we got saved files,
                  // the current file was saved, so ignore any rejected entries for it
                  if (data.rejected && data.rejected.length > 0) {
                    // If we have saved files, the current file was saved - skip processing rejected
                    const currentFileWasSaved = data.saved && data.saved.length > 0;
                    
                    if (!currentFileWasSaved) {
                      // Only process rejected if we didn't save anything
                      data.rejected.forEach(rejectedPath => {
                        // Extract the base path (remove error messages)
                        const basePath = rejectedPath.split(' (error:')[0].split(' (Network error)')[0].split(' (Upload error)')[0];
                        
                        // Skip extended attribute files entirely - they should never be in rejected
                        if (isExtendedAttribute(basePath)) {
                          return;
                        }
                        
                        // Check if this rejected path matches the file we just sent
                        // Only process files that we actually sent to the backend
                        const matchesCurrentFile = basePath === path || filesActuallySent.has(basePath);
                        
                        if (matchesCurrentFile) {
                          // This file was rejected
                          allRejected.push(rejectedPath);
                        }
                      });
                    }
                    // If currentFileWasSaved is true, we skip all rejected entries for this upload
                  }
                  
                  resolve();
                } catch (err) {
                  // If parsing fails, mark current file as rejected (if not extended attribute)
                  if (!isExtendedAttribute(path)) {
                    allRejected.push(path);
                  }
                  resolve(); // Continue with next file even if parsing fails
                }
              } else {
                try {
                  const data = JSON.parse(xhr.responseText);
                  // HTTP error - mark current file as rejected (if not extended attribute)
                  if (!isExtendedAttribute(path)) {
                    allRejected.push(path + (data.error ? ` (${data.error})` : ''));
                  }
                } catch (err) {
                  // Parsing error - mark current file as rejected (if not extended attribute)
                  if (!isExtendedAttribute(path)) {
                    allRejected.push(path);
                  }
                }
                resolve(); // Continue with next file even on error
              }
            });

            xhr.addEventListener("error", () => {
              currentUploadXHR = null;
              // Update uploadedBytes immediately even on error
              uploadedBytes += file.size;
              
              // Update progress bar
              const percentComplete = Math.round((uploadedBytes / totalSize) * 100);
              progressBarFill.style.width = percentComplete + "%";
              progressStatus.textContent = percentComplete + "%";
              
              // Only add to rejected if not an extended attribute file
              if (!isExtendedAttribute(path)) {
                allRejected.push(path + " (Network error)");
              }
              resolve(); // Continue with next file
            });

            xhr.addEventListener("abort", () => {
              currentUploadXHR = null;
              uploadCancelled = true;
              reject(new Error("Upload cancelled"));
            });

            xhr.open("POST", "{{ url_for('upload') }}");
            xhr.send(fd);
          });
        } catch (err) {
          if (err.message === "Upload cancelled") {
            break;
          }
          // Continue with next file on other errors
          uploadedBytes += file.size;
          // Update progress bar
          const percentComplete = Math.round((uploadedBytes / totalSize) * 100);
          progressBarFill.style.width = percentComplete + "%";
          progressStatus.textContent = percentComplete + "%";
          // Only add to rejected if not an extended attribute file
          if (!isExtendedAttribute(path)) {
            allRejected.push(path + " (Upload error)");
          }
        }
      }

      // Update final progress
      if (!uploadCancelled) {
        progressBarFill.style.width = "100%";
        progressStatus.textContent = "100%";
      }

      // Show results
      currentUploadXHR = null;
      uploadProgress.classList.remove("active");
      
      if (uploadCancelled) {
        feedback.className = "feedback";
        feedback.textContent = "Upload cancelled.";
      } else {
        let feedbackHTML = "";
        
        // Accepted files
        if (allSaved.length > 0) {
          feedback.className = "feedback success";
          feedbackHTML += `Accepted ${allSaved.length} file${allSaved.length !== 1 ? 's' : ''}: <ul><li>` + allSaved.join("</li><li>") + "</li></ul>";
        }
        
        // Unselected files
        if (allUnselected.length > 0) {
          feedback.className = feedback.className || "feedback";
          if (feedbackHTML) feedbackHTML += "<br>";
          feedbackHTML += `Unselected ${allUnselected.length} file${allUnselected.length !== 1 ? 's' : ''}: <ul><li>` + allUnselected.join("</li><li>") + "</li></ul>";
        }
        
        // Rejected files (only files that were selected but failed)
        if (allRejected.length > 0) {
          feedback.className = feedback.className || "feedback error";
          if (feedbackHTML) feedbackHTML += "<br>";
          feedbackHTML += `Rejected ${allRejected.length} file${allRejected.length !== 1 ? 's' : ''}: <ul><li>` + allRejected.join("</li><li>") + "</li></ul>";
        }
        
        if (feedbackHTML) {
          feedback.innerHTML = feedbackHTML;
        } else {
          feedback.textContent = "No files uploaded.";
        }
      }
      
      hideFolderBrowser();
      filesInput.value = "";
      folderInput.value = "";
      updateSubmit();
      confirmBtn.disabled = false;
      cancelBtn.disabled = false;
      if (submitBtn) submitBtn.disabled = false;
    });

    function updateSubmit() {
      // Function kept for compatibility but button removed
      // const hasFiles = filesInput.files.length > 0;
      // if (submitBtn) submitBtn.disabled = !hasFiles;
    }

    // When clicking the zone, show a simple prompt to choose files or folder
    zone.addEventListener("click", (e) => { 
      if (!e.target.closest(".linkBtn")) {
        // #region agent log
        fetch('http://127.0.0.1:7244/ingest/748ea684-e073-4f05-a7f9-757a7041c34a',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'upload.html:992',message:'zone clicked - calling folderInput.click',data:{folderBrowserActive:folderBrowser.classList.contains('active'),folderInputValue:folderInput.value},timestamp:Date.now(),runId:'debug1',hypothesisId:'E'})}).catch(()=>{});
        // #endregion
        folderInput.click();
      }
    });
    zone.addEventListener("keydown", (e) => { 
      if (e.key === "Enter" || e.key === " ") { 
        e.preventDefault(); 
        folderInput.click(); 
      } 
    });
    filesInput.addEventListener("change", updateSubmit);

    zone.addEventListener("dragover", (e) => { e.preventDefault(); zone.classList.add("dragover"); });
    zone.addEventListener("dragleave", () => zone.classList.remove("dragover"));
    zone.addEventListener("drop", (e) => {
      e.preventDefault();
      zone.classList.remove("dragover");
      folderInput.value = "";
      filesInput.files = e.dataTransfer.files;
      updateSubmit();
    });

    form.addEventListener("submit", async (e) => {
      // Only handle file uploads here, folder uploads are handled by confirmBtn
      if (folderInput.files.length > 0) {
        e.preventDefault();
        return;
      }
      
      const fileList = filesInput.files;
      if (!fileList.length) { e.preventDefault(); return; }
      e.preventDefault();
      
      // Show progress bar for regular file uploads too
      uploadProgress.classList.add("active");
      progressBarFill.style.width = "0%";
      progressStatus.textContent = "0%";
      progressDetails.textContent = "Preparing upload...";
      
      if (submitBtn) submitBtn.disabled = true;
      feedback.textContent = "";
      feedback.className = "feedback";

      // Build file array
      const fileArray = [];
      for (let i = 0; i < fileList.length; i++) {
        const f = fileList[i];
        if (!f.name) continue;
        fileArray.push({ file: f, path: f.name });
      }

      // Calculate total size
      let totalSize = 0;
      fileArray.forEach(({ file }) => {
        totalSize += file.size;
      });

      progressDetails.textContent = `Uploading ${fileArray.length} file${fileArray.length !== 1 ? 's' : ''} (${formatSize(totalSize)})...`;

      // Track upload progress
      let uploadedBytes = 0;
      const allSaved = [];
      const allRejected = [];
      const allUnselected = []; // Not applicable for regular file uploads, but keep for consistency
      let uploadCancelled = false;

      // Upload files sequentially, one at a time
      for (let i = 0; i < fileArray.length; i++) {
        if (uploadCancelled) break;
        
        const { file, path } = fileArray[i];
        const currentFileIndex = i + 1;
        
        try {
          await new Promise((resolve, reject) => {
            const fd = new FormData();
            fd.append("files", file);
            fd.append("paths", path);

            const xhr = new XMLHttpRequest();
            currentUploadXHR = xhr;
            
            xhr.upload.addEventListener("progress", (e) => {
              if (e.lengthComputable && !uploadCancelled) {
                const currentFileProgress = e.loaded;
                const totalUploaded = uploadedBytes + currentFileProgress;
                const percentComplete = Math.round((totalUploaded / totalSize) * 100);
                
                progressBarFill.style.width = percentComplete + "%";
                progressStatus.textContent = percentComplete + "%";
                
                const uploadedSize = formatSize(totalUploaded);
                const totalSizeStr = formatSize(totalSize);
                progressDetails.textContent = `[${currentFileIndex}/${fileArray.length}] Uploading ${path}... ${uploadedSize} / ${totalSizeStr}`;
              }
            });

            xhr.addEventListener("load", () => {
              currentUploadXHR = null;
              // Update uploadedBytes immediately when file completes
              uploadedBytes += file.size;
              
              // Update progress bar to show completed file
              const percentComplete = Math.round((uploadedBytes / totalSize) * 100);
              progressBarFill.style.width = percentComplete + "%";
              progressStatus.textContent = percentComplete + "%";
              
              if (xhr.status >= 200 && xhr.status < 300) {
                try {
                  const data = JSON.parse(xhr.responseText);
                  
                  if (data.saved && data.saved.length) {
                    allSaved.push(...data.saved);
                  }
                  if (data.rejected && data.rejected.length) {
                    allRejected.push(...data.rejected);
                  }
                  
                  resolve();
                } catch (err) {
                  allRejected.push(path);
                  resolve();
                }
              } else {
                try {
                  const data = JSON.parse(xhr.responseText);
                  allRejected.push(path + (data.error ? ` (${data.error})` : ''));
                } catch (err) {
                  allRejected.push(path);
                }
                resolve();
              }
            });

            xhr.addEventListener("error", () => {
              currentUploadXHR = null;
              // Update uploadedBytes immediately even on error
              uploadedBytes += file.size;
              
              // Update progress bar
              const percentComplete = Math.round((uploadedBytes / totalSize) * 100);
              progressBarFill.style.width = percentComplete + "%";
              progressStatus.textContent = percentComplete + "%";
              
              allRejected.push(path + " (Network error)");
              resolve();
            });

            xhr.addEventListener("abort", () => {
              currentUploadXHR = null;
              uploadCancelled = true;
              reject(new Error("Upload cancelled"));
            });

            xhr.open("POST", "{{ url_for('upload') }}");
            xhr.send(fd);
          });
        } catch (err) {
          if (err.message === "Upload cancelled") {
            break;
          }
          uploadedBytes += file.size;
          // Update progress bar
          const percentComplete = Math.round((uploadedBytes / totalSize) * 100);
          progressBarFill.style.width = percentComplete + "%";
          progressStatus.textContent = percentComplete + "%";
          allRejected.push(path + " (Upload error)");
        }
      }

      // Update final progress
      if (!uploadCancelled) {
        progressBarFill.style.width = "100%";
        progressStatus.textContent = "100%";
      }

      // Show results
      currentUploadXHR = null;
      uploadProgress.classList.remove("active");
      
      if (uploadCancelled) {
        feedback.className = "feedback";
        feedback.textContent = "Upload cancelled.";
      } else {
        let feedbackHTML = "";
        
        // Accepted files
        if (allSaved.length > 0) {
          feedback.className = "feedback success";
          feedbackHTML += `Accepted ${allSaved.length} file${allSaved.length !== 1 ? 's' : ''}: <ul><li>` + allSaved.join("</li><li>") + "</li></ul>";
        }
        
        // Unselected files (not applicable for regular file uploads, but keep structure consistent)
        if (allUnselected.length > 0) {
          feedback.className = feedback.className || "feedback";
          if (feedbackHTML) feedbackHTML += "<br>";
          feedbackHTML += `Unselected ${allUnselected.length} file${allUnselected.length !== 1 ? 's' : ''}: <ul><li>` + allUnselected.join("</li><li>") + "</li></ul>";
        }
        
        // Rejected files (only files that were selected but failed)
        if (allRejected.length > 0) {
          feedback.className = feedback.className || "feedback error";
          if (feedbackHTML) feedbackHTML += "<br>";
          feedbackHTML += `Rejected ${allRejected.length} file${allRejected.length !== 1 ? 's' : ''}: <ul><li>` + allRejected.join("</li><li>") + "</li></ul>";
        }
        
        if (feedbackHTML) {
          feedback.innerHTML = feedbackHTML;
        } else {
          feedback.textContent = "No files uploaded.";
        }
      }
      
      filesInput.value = "";
      updateSubmit();
      if (submitBtn) submitBtn.disabled = false;
    });

    // Close browser on Escape key
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && folderBrowser.classList.contains("active")) {
        hideFolderBrowser();
      }
    });
  </script>
</body>
</html>
